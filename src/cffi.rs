use crate::compiler::Compiler;
use crate::ethabi::{Function, Contract, param_type::ParamType::*};
use std::path::PathBuf;
use std::fs;
use std::string::String;

/// Generate C header file containing the functions in compiled contracts
pub struct CFFIGenerator {
    fn_names: Vec<String>,
    fn_stubs: Vec<String>,
}

impl CFFIGenerator {
    pub fn new() -> Self {
        let fn_stubs = Vec::new();
        let fn_names = Vec::new();
        Self {
            fn_stubs,
            fn_names,
        }
    }

    fn add_stub(&mut self, fn_name: &str, params: &[String]) {
        let fn_stub = format!("extern void {}({});", fn_name, params.join(", "));
        self.fn_stubs.push(fn_stub.to_string());
        self.fn_names.push(fn_name.to_owned());
    }

    pub fn add_constructor(&mut self, name: &str) {
        let fn_name = Compiler::format_fn_name(name, false);
        let params = vec![
            "i8* msg".to_owned(),
            "long msg_len".to_owned(),
            "long* ret_offset".to_owned(),
            "long* ret_len".to_owned(),
            "i8* storage".to_owned()
        ];
        self.add_stub(&fn_name, &params);
    }

    pub fn add_runtime(&mut self, name: &str) {
        let fn_name = Compiler::format_fn_name(name, true);
        let params = vec![
            "i8* msg".to_owned(),
            "long msg_len".to_owned(),
            "long* ret_offset".to_owned(),
            "long* ret_len".to_owned(),
            "i8* storage".to_owned()
        ];
        self.add_stub(&fn_name, &params);
    }

    pub fn add_contract(&mut self, contract_name: &str, contract: Contract) {
        let inputs = contract.constructor.as_ref().map(|i|i.inputs.clone()).unwrap_or(vec![]);
        self.add_abi_function(contract_name, &Function {
            name: "constructor".to_owned(),
            inputs,
            outputs: vec![],
            constant: false,
        }, 0);
        // abi formatters
        for (_name, funs) in &contract.functions {
            for (idx, fun) in funs.iter().enumerate() {
                self.add_abi_function(contract_name, fun, idx);
            }
        }
        self.add_constructor(contract_name);
        self.add_runtime(contract_name);
    }

    pub fn add_abi_function(&mut self, contract_name: &str, fun: &Function, idx: usize) {
        let fn_name = Compiler::format_abi_fn_name(contract_name, fun, idx);
        let mut params = Vec::new();
        params.push("i8* tx".to_owned());
        params.push("int* tx_size".to_owned());
        for param in &fun.inputs {
            let ty = match param.kind {
                Address => "i8*",
                Bytes => "i8*",
                Int(8) | Uint(8) => "byte",
                Int(16) | Uint(16) => "short",
                Int(32) | Uint(32) => "int",
                Int(64) | Uint(64) => "long",
                Int(_) | Uint(_) => "i8*",
                Bool => "int",
                String => "i8*",
                Array(_) => "i8*",
                FixedBytes(_) => "i8*",
                FixedArray(_, _) => "i8*",
                Tuple(_) => "i8*",
            };
            params.push(format!("{} {}", ty, param.name));
        }

        self.add_stub(&fn_name, &params);
    }

    pub fn generate(&self, outdir: &PathBuf, ir: &str) {
        let outdir = outdir.as_os_str().to_str().unwrap();
        // create folders
        std::fs::create_dir_all(outdir).expect("unable to create output directory");
        std::fs::create_dir_all(format!("{}/src", outdir)).expect("unable to create output/src directory");

        // write ir
        fs::write(format!("{}/src/contracts.ll", outdir), ir).expect("cannot write ir");

        // format header
        let mut contents = String::new();
        contents += &format!("/* automatically generated by solenoid {} */\n", env!("CARGO_PKG_VERSION"));
        contents += "\n";
        contents += "#include \"rt.h\"\n";
        contents += "\n";
        contents += &self.fn_stubs.join("\n\n");
        contents += "\n";
        let contract_header = format!("{}/src/contracts.h", outdir);
        let runtime_header = format!("{}/src/rt.h", outdir);
        let bindings_filename = format!("{}/src/bindings.rs", outdir);

        // write c header
        fs::write(&contract_header, contents).expect("unable to write contracts.h header");
        Self::copy_deps(&outdir);

        // write rust bindings
        let mut builder = bindgen::builder()
            .header(&contract_header)
            .header(&runtime_header);
        for f in &self.fn_names {
            builder = builder.whitelist_function(f);
        }

        for f in &["prt"] {
            builder = builder.whitelist_function(f);
        }

        let vars = [
            "stack",
            "storage",
            "sp",
        ];
        for var in &vars {
            builder = builder.whitelist_var(var);
        }

        let bindings = builder
            .generate()
            .expect("unable to generate bindings");
        bindings.write_to_file(bindings_filename).expect("unable to write bindings");
    }

    pub fn copy_deps(outdir: &str) {
        macro_rules! include {
            (root: $($x:expr,)*) => {
                $(
                    fs::write(&format!("{}/{}", outdir, $x), include_str!(concat!("../runtime/", $x))).unwrap();
                )*
            };
            (src: $($x:expr,)*) => {
                $(
                    fs::write(&format!("{}/src/{}", outdir, $x), include_str!(concat!("../runtime/", $x))).unwrap();
                )*
            };
        }
        include!(root:
            "Makefile",
        );
        include!(src:
            "rt.c",
            "rt.h",
            "arith.ll",
            "main.c",
        );
    }
}