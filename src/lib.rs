pub mod opcode;

pub fn parse(bytes: &[u8]) {
    for byte in bytes {
        dbg!(byte);
    }
    for opcode in opcode::Disassembly::from_bytes(bytes).unwrap().instructions {
        println!("{:?}", opcode);
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use hex::FromHex;

    #[test]
    fn it_works() {
        let code = "608060405234801561001057600080fd5b506040516101403803806101408339818101604052602081101561003357600080fd5b8101908080519060200190929190505050806000806101000a81548160ff0219169083151502179055505060d48061006c6000396000f3fe6080604052348015600f57600080fd5b506004361060325760003560e01c80636d4ce63c146037578063cde4efa9146057575b600080fd5b603d605f565b604051808215151515815260200191505060405180910390f35b605d6075565b005b60008060009054906101000a900460ff16905090565b6000809054906101000a900460ff16156000806101000a81548160ff02191690831515021790555056fea265627a7a7231582082bcd0833ba0da688a9423e31c3ac40adacca43eb13e585f36ef1dd07e14c45864736f6c63430005110032";
        let bytes: Vec<u8> = Vec::from_hex(code).expect("Invalid Hex String");

        parse(&bytes);
    }
}
